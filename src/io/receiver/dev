# serial 수신부
자식 프로세스 포크하고 자식과 부모 프로세스의 CPU 따로 고정.
자식 프로세스의 우선순위를 높게 설정.

자식 프로세스에서 1350bps 의 클락포트의 상승엣지를 감지하여 DATA포트에서 H/L 읽기.

부모와 자식은 공유 버퍼를 가짐.
자식은 SyncWord를 찾아서 다음 SyncWord 사이의 1Cycle 을 찾으면
공유버퍼에 [0, ...timestemp, ...1Cycle] 을 저장하고
부모에서 공유버퍼의 어느 부분부터 어느 부분까지 읽으라고 스트림으로 index 를 전달.
부모는 스트림으로 index 를 받으면
Cycle 을 읽고 0 -> 1 로 수정함.
자식은 1Cycle 을 찾을 때마다 1 인지 확인하고
1 -> 0 으로 수정한 뒤 찾은 Cycle 을 기록하고 스트림으로 index 를 전달하는 것을 반복함.

1Cycle 을 찾는것은 최소한 192클락이 소요됨으로
다음 사이클까지 부모프로세스가 읽지 못할 가능성은 매우 낮다.
하지만 안전하게 하기위해 공유버퍼 사이즈를 충분히 늘려 n 개의 영역으로 나누고
자식프로세스는 버퍼의 각 영역의 0번째 index 를 확인하면서 부모 프로세스가 읽었는지 알 수 있고
읽지 않는 영역은 건너뛰고 읽은 영역에 데이터를 쓰고 스트림으로 Index 를 전달함.

# status
수신기에 받는 신호
High = 송신기가 켜져있음을 의미
Low = 송신기가 꺼져있음을 의미

실험적으로 알게된 3 가지 상황
- 모든것이 정상 = High
- 송신기가 켜지는 순간 = 수백 밀리세컨 마다 수 마이크로초 단위로 High-Low 반복하다가 수초 정도 후에 High 안정.
- 송신기가 켜져있지만 기기넘버 검증 실패하거나 데이터 오류인경우 = 1초 사이클로 High Low 반복함. High 600ms, Low 400ms 정도

디바운싱으로 잡을수 있는건 잡고
안돼는건 1초 사이클로 High Low 반복하는것을 잡아서 Low 로 여겨야함.