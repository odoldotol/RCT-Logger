# Spec

<br>

- Raspberry Pi 4 Model B, 4GB RAM, BCM2711(4Core&Thread)

- SanDisk Extreme | microSDXC UHS-I Card, 64GB

- Raspberry Pi OS Lite (64-bit), 438MB, Kernel version: 6.6, Debian version: 12 (bookworm)

- RTC - DS3231  
[] RTC 백업 베터리 방전된후 전원 끈겨서 초기화시 전략?

<br><br><br>

# 현장

<br>

- 네트워크 없음, 인터넷 불가능

- 크레인 탑에 설치하는 특성상 접근 어려움

- 설치시 수개월 또는 수년간 접근 안할수도 있음

- 설치전 수개월 또는 수년간 창고에 방치될 수도 있음 => RTC 백업 베터리 방전 문제  

- [] 외부 노이즈 테스트 => 싱크워드 찾기 오차허용, 보정, 검증, summarizing

<br><br><br>

# 전원 중단 & 디스크

<br>

DB는 일정 주기별로 데이터를 디스크에 씀.  
그외 앱 로그, 시스템로그, 캐시, 임시파일 등 디스크 쓰기 많진 않을것.  
이미 부팅관련 파티션 분리 등등 시스템이 잘 되어있는것으로 보임.

쓰기도중 전원이 중단되는 경우 혹은 SD 카드의 수명(충분함)을 고려한 조치가 필요할 수 있음.

<br>

## 1 단계 - 무조치

<br>

지금도 충분함.

<br>

## 2 단계 - log2ram

<br>

log2ram 을 이용하여 로그 쓰기만 관리.

<br>

## [] 3 단계 - 오버레이 FS + log2ram

<br>

- 영구 저장 파티션, 마운트, 저널링(ext4)

- DB 와 log 를 이 파티션에 백업 (log2ram 이용)

- 오버레이 FS 를 전체 시스템에 적용  
=> DB 와 log 를 배치로 영구 파티션에 쓰고 나머지 쓰기는 ram 에만 써서 휘발시킴.

<br><br><br>

# 365 24

<br>

## 앱

<br>

PM2 (5.4.3)  
시작, 리로드, 모니터

pigpio 는 하나의 프로세스만 사용가능. 복수의 프로세스가 접근하려하면 에러발생.  
차일드가 pigpio 사용.

<br>

! 차일드 프로세스를 죽이지 못하고 부모프로세스가 죽는 경우
> 부모가 재시작하면서 차일드를 만듦.<br>
차일드는 pigpio 중복으로 정상적으로 Open 까지 못가고 무한 재시작에 빠질 수 있음.<br>
부모는 차일드의 open 을 기다리느라 앱이 정상적으로 Working 상태에 이르지 못함.<br>
heartbeat 가 Working 이후에 시작하기 때문에 시스템에서 앱에 문제가 있음을 감지하고 리부트함.

<br>

[] 그 외 좀비프로새스 문제 방지 => node 프로세스의 갯수 모니터링, Pm2 데몬 갯수 모니터링

<br>

## 시스템

<br>

리부트 없이는 죽지않는 시스템  
[] 안전한 리부트(백업)

<br>

### 모니터링 리부트
Watchdog
- 주요 프로세스 heartbeat
- [] 메모리 - 누수, 과도한 사용  
  App - 80-90M(평시), 140M(다운로드)  
  시스템 - WIFI, BT 등 불필요한 백그라운드 비활성화 하고 오버레이FS 적용 후에 체크해볼것  

- [] CPU - 과도한 부하, 특정 프로세스의 무한 루프  
  cat /proc/loadavg  
  평시 - 0.37 0.37 0.36 1/191 2488  
  다운로드 시작 피크 - 2.20 1.11 0.65 4/205 2588  
  다운로드 중간 값 - 1.52 1.26 0.79 3/206 2635  
  다운로드 마무리 피크 - 2.01 1.50 0.97 2/206 2668  

  기능 전부 구현하고 디자인 집어넣으니 (로깅없이)  
  1.28 0.68 0.34 2/206 2569  
  1.06 0.97 0.57 3/207 2656  
  1.36 1.10 0.68 3/206 2662  
  1.19 1.16 0.93 3/205 2676  

  (로깅 있시)  
  1.70 0.95 0.59 4/209 3864  
  0.?? ?.?? 1.2?  

- [] 디스크 - 에러, I/O 지연, 파일 시스템 이상

- [] 로그 및 커널 메시지 - dmesg, syslog, journalctl 등에서 치명적인 오류나 커널 패닉 메시지

- [] 온도 - CPU 온도  
  평시 - 40도  
  다운로드 피크 - 65도  

- [] 전원 - 전압 불안정, 전원 공급 이상 여부

<br>

### 정기적 리부트
- AR20, download 등 확인해서 지연할 수 있어야함
- 근무시간에는 절대 리부트를 예약하지 않아야함

<br>

### [] 로테이트 (64GB 면 50년은 써야 꽉찰것 같은데...)
- DB
- 앱로그
- 시스템로그

<br>

### 발열
80도부터 성능제한, 셧다운 가능성 있다고함.  
현, 동절기이긴 하나, 방열케이스 장착후 40도 선에서 관리됨.  
일단, 로거에서 주기적 온도 체크. => 별도 모니터링 프로세스에 통합  

- 다운로드할떄 온도상승 보임.
  - 3일치정도할때 3분정도동안 10도정도 상승함.
  - 10몇일치 할떄 65도 이상도 관측함.

=> 다운로드 열관리만 잘 하면 쿨링 팬 필요없음.  
다운로드에 1코어만 이용하는 것 만으로도 이미 열관리가 됨.

<br><br><br>

# Network(Wifi, SSH)

<br>

## development

<br>

Wifi 자동 연결
Wifi 통한 SSH 접속

<br>

## production

<br>

[] Wifi, 블루투스 등 불필요한 장치 끄기
[] (복구전략) Ethernet 이용한 SSH 접속

<br><br><br>

# GPIO

<br>

## Lib

<br>

아래 두 라이브러리를 사용해서 GPIO 제어.

<br>

### pigpio
alert 은 수 마이크로초 단위로 뱐화를 감지하지만 이벤트 핸들러가 실행되는 타이밍의 오차는 1ms 까지 올라간다.  
interrupt 받는게 합리적이나, 문제가 있어보임.  
pigpio C 라이브러리는 /dev/gpiomem 같은 장치 파일에 접근하여 GPIO를 제어하는데,  
이 장치 파일은 한 번에 한 프로세스만 안전하게 접근할 수 있도록 되어 있어 멀티프로세싱 까다로움.  
정확도가 중요한 부분, 시리얼을 읽는 프로세스에서만 사용.  

<br>

### onoff
edge 는 수십 마이크로초 의 오차를 가지고 이벤트 핸들러를 실행할 수 있다.  
제너럴하게 사용.  

<br>

## Serial Data

<br>

OKI MSM6882-5, RT/RD  
1200bps  

GPIO  
RT - SYNC_CLK  
RD - SERIAL_DATA  

SYNC_CLK 의 상승엣지(데이터 중위)에서 SERIAL_DATA 읽기  

[Data_spec](./data_spec.md)

<br>

### 정확도, 안정성
- onoff < node-libgpiod < pigpio
- 이벤트 루프 분리, 프로세스 분리
  - 차일드프로세스 회복성(재시작, heartbeat)
- 최소화 하고 scheduling policy, priority 조정
- stdio(Uint8Array) 로 데이터 전달
- [] timestamp 정확도 (현재, 오차범위: +메인 프로세스의 이벤트루프 레이턴시)
- 보정
  - [] 1~2|3 개 클락 밀리는것 보정해서 검증하고 푸시하기
  - [] 사이클 배수 단위로 지연되어 싱크워드 찾는경우, 나눠서 검증하고 푸시하기
  - [] 사이클 배수에 근사한 단위로 지연되는 경우 보정하고 검증, 푸시하기

[More](./src/logger/io/receiver/dev)

<br>

## Receiver Status (AR20) 신호 문제

<br>

디바운싱, 타이머 로 해결

[More](./src/logger/io/receiver/dev)

<br><br><br>

# database

<br>

- Log-Structured File System
- append-only
- segment
- binary  
[] 쓰기/읽기 안정성, 복구전략

[More](./src/database/dev)

<br><br><br>

# USB
[More](./src/logger/io/usb/dev)

<br>

## mount, umount 를 안전하게 제어

<br>

Udev 이벤트를 서버에서 다룸  
USB 연결 제한  
유저의 행동(USBStorage 추가&제거), 서버 작업(다운로드 완료|에러) 를 안전하게 다룸  

<br><br><br>

# 로그를 엑셀로 USB Storage 에 다운로드

<br>

세그먼트 스트림읽기 -> 엑셀 스트림쓰기  
각 로그를 1초 단위로 요약  
하루치를 하나의 파일로, 3만여개의 열 예상.  
데이터수신(stdio), led(timer) 등 이벤트루프 병목 없어야함.  
CPU 온도 70도시 이상이면 시작하지 않음  
강제로 USB Storage 를 뽑을시에 graceful 다운로드 중지 및 리소스 해지  
[] 한번에 최대 N일치만 허용하기  
[] rangeQuery 읽기 및 다운로드로그/에러 출력 인/디코딩 전략  
[] 다운로드 성능(속도) 개선  

[More](./src/logger/app/log/dev)

<br><br><br>

# LED

<br>

간단 상태표시, USB 및 다운로드, heartbeat 상호작용  
[] blink 의 한 사이클 내에서 HIGH 가 LOW 보다 짧게 하기  

<br><br><br>

# More

<br>

### [] 패키징

<br>

### [] 간단한 사용자 메뉴얼 제공하기
[Manual.dev](./Manual)

<br>

### [] 출고 Test 구축
[Test_Senario.dev](./test)

<br>

### [] GPIO, RTC 등 모든 연결 없이도 전원만으로 부팅, 앱실행 문제없어야함

<br>

### [] 시리얼 데이터 사이클의 처음부터 끝까지를 비트로 다루기

<br>

### TDD 배제 이유
아래와 같은 이유로 생산성이 심각하게 떨어진다 판단.
- 어차피 장비로 테스트를 진행해야함
- 라즈베리파이 환경에서만 동작하는 코드 | 라이브러리가 존재 => 모킹 복잡성 증가, 라즈베리파이 없이 E2E 테스트 무용지물
- 일부분에만 유닛테스트 적용하며 TDD 적용하기에 전체 개발 시퀀스가 복잡해짐
- 혼자 개발, 제품 완성 후 리팩터링 예정 없음

<br>

판매하면 모니터링이 불가능한 제품인 특성과 테스트 코드 없는 개발이 합쳐져 걱정이 있었으나  
아래와 같은 방법으로 극복하고자 함.
- 최소 기능, 예외 상황 최대한 제거, 안정성을 최우선한 코드 선택
- 충분히 작게 나누고 코드의 직관성을 높이는 아키텍처를 고민하여 개발
- 개발주기에서 샘플 개발을 적극 활용, 충분히 많은 실행과 모니터링
- 코드와 문서를 가까이 두고 긴밀하게 관리

<br><br><br>

---
---

<br><br><br>

# May

<br>

### DB 안정성 + 복구전략
- 쓰기 복구 및 복원 전략
- 읽기 검사 전략
- 프로세스 나누고 소켓으로 통신

<br>

### 로거에서 가능한 검증 3 가지 / 16 bits error limit / Address Parity Reverse

<br>

### 전원부 회로

<br>